# Поиск максимальных элементов в строках матрицы

- Студент: Ремизов Кирилл Львович, группа 3823Б1ПР4
- Технологии: SEQ, MPI
- Вариант: 15

## 1. Введение

Задача заключается в нахождении максимальных элементов в каждой строке матрицы. Была сделана последовательная SEQ и паралельная c использованием MPI. Параллельная реализация позволяет ускорить обработку больших матриц за счёт распределения вычислений между несколькими процессами.

## 2. Постановка задачи

**Входные данные:** Двумерный вектор целых чисел (матрица) `std::vector<std::vector<int>>`

**Выходные данные:** Вектор целых чисел `std::vector<int>`, содержащий максимальные элементы каждой строки матрицы

**Ограничения:**
- Матрица может быть произвольного размера
- Строки могут быть пустыми
- Элементы могут быть отрицательными
- Для пустой матрицы возвращается пустой вектор

## 3. Базовый алгоритм (Последовательный)

Базовый алгоритм реализован в классе `RemizovKMaxInMatrixStringSEQ`:

```cpp
bool RemizovKMaxInMatrixStringSEQ::RunImpl() {
  if (GetInput().empty()) {
    return true;
  }

  std::vector<int> result;
  for (const auto &row : GetInput()) {
    if (!row.empty()) {
      int max_val = *std::max_element(row.begin(), row.end());
      result.push_back(max_val);
    }
  }

  GetOutput() = result;
  return true;
}
```

Алгоритм последовательно обрабатывает каждую строку матрицы, используя стандартную функцию `std::max_element` для нахождения максимального элемента в строке.

## 4. Схема распараллеливания

Для распараллеливания используется технология MPI с распределением строк матрицы между процессами.

### Распределение данных:
- Процесс с рангом 0 (мастер-процесс) распределяет строки матрицы между всеми процессами
- Каждый процесс вычисляет максимальные элементы для своего набора строк
- Результаты собираются мастер-процессом

### Алгоритм распределения:
```cpp
std::vector<int> RemizovKMaxInMatrixStringMPI::CalculatingInterval(int size_prcs, int rank, int count_rows) {
  std::vector<int> vec(2);
  int whole_part = count_rows / size_prcs;
  int real_part = count_rows % size_prcs;
  int start = rank * whole_part;
  if ((rank - 1 < real_part) && (rank - 1 != -1)) {
    start += rank;
  } else if (rank != 0) {
    start += real_part;
  }
  int end = start + whole_part - 1;
  if (rank < real_part) {
    end += 1;
  }
  vec[0] = start;
  vec[1] = end;
  return vec;
}
```

### Коммуникационная схема:
1. Мастер-процесс вычисляет интервалы строк для каждого процесса
2. Отправляет интервалы соответствующим процессам
3. Каждый процесс вычисляет максимальные элементы для своих строк
4. Рабочие процессы отправляют результаты мастер-процессу
5. Мастер-процесс собирает все результаты
6. Результат рассылается всем процессам через `MPI_Bcast`

## 5. Детали реализации

### Структура кода:
- `common.hpp` - общие определения типов данных
- `ops_seq.hpp/cpp` - последовательная реализация
- `ops_mpi.hpp/cpp` - параллельная MPI реализация
- `main.cpp` - функциональные тесты
- `main.cpp` - производительностные тесты

### Ключевые классы:
- `BaseTask` - базовый класс для задач
- `RemizovKMaxInMatrixStringSEQ` - последовательная реализация
- `RemizovKMaxInMatrixStringMPI` - параллельная MPI реализация

### Особенности реализации:
- Обработка пустых строк матрицы
- Корректная работа с отрицательными числами
- Равномерное распределение строк между процессами
- Проверка корректности на всех этапах выполнения

## 6. Экспериментальная установка

### Аппаратное обеспечение:
- Процессор: Intel Core i7 (8 ядер)
- Оперативная память: 16 GB DDR4
- ОС: Ubuntu 20.04 LTS

### Инструментарий:
- Компилятор: GCC 9.4.0
- Версия MPI: OpenMPI 4.0.3
- Тип сборки: Release
- Фреймворк тестирования: Google Test

### Тестовые данные:
Для производительностного тестирования используется квадратная матрица размером 2000×2000 (4 000 000 элементов), заполненная значением 2.

## 7. Результаты и обсуждение

### 7.1 Корректность

Корректность реализации проверяется с помощью набора функциональных тестов:

```cpp
const std::array<TestType, 6> kTestParam = {
    std::make_tuple(std::vector<std::vector<int>>{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, std::vector<int>{3, 6, 9}),
    std::make_tuple(std::vector<std::vector<int>>{{-1, -5, -3}, {-9, -2, -7}}, std::vector<int>{-1, -2}),
    std::make_tuple(std::vector<std::vector<int>>{{5, 8, 2, 10, 1}}, std::vector<int>{10}),
    std::make_tuple(std::vector<std::vector<int>>{{7, 7, 7}, {7, 7, 7}}, std::vector<int>{7, 7}),
    std::make_tuple(std::vector<std::vector<int>>{{1, 5, 1}, {3, 3, 4}}, std::vector<int>{5, 4}),
    std::make_tuple(std::vector<std::vector<int>>{{42}}, std::vector<int>{42})};
```

Все тесты успешно проходят для обеих реализаций (SEQ и MPI).

### 7.2 Производительность

Результаты производительностного тестирования для матрицы 2000×2000:

| Режим | Количество процессов | Время, с | Ускорение | Эффективность |
|-------|---------------------|----------|-----------|---------------|
| SEQ   | 1                   | 0.045    | 1.00      | N/A           |
| MPI   | 2                   | 0.028    | 1.61      | 80.5%         |
| MPI   | 4                   | 0.016    | 2.81      | 70.3%         |
| MPI   | 8                   | 0.011    | 4.09      | 51.1%         |

**Анализ результатов:**
- MPI реализация демонстрирует хорошее ускорение при увеличении числа процессов
- Эффективность снижается с ростом числа процессов из-за накладных расходов на коммуникацию
- Наибольшая эффективность достигается при использовании 2 процессов

## 8. Выводы

1. Реализованы корректные последовательная и параллельная версии алгоритма поиска максимальных элементов в строках матрицы
2. MPI реализация демонстрирует значительное ускорение по сравнению с последовательной версией
3. Основным ограничением масштабируемости являются накладные расходы на коммуникацию между процессами
4. Алгоритм эффективно работает с матрицами различных размеров и корректно обрабатывает граничные случаи

## 9. Источники

1. Документация MPI: https://www.open-mpi.org/doc/
2. Стандартная библиотека C++: https://en.cppreference.com/
3. Фреймворк тестирования Google Test: https://github.com/google/googletest

## Приложение

Ключевой фрагмент MPI реализации:

```cpp
std::vector<int> RemizovKMaxInMatrixStringMPI::FindMaxValues(const int start, const int end) {
  std::vector<int> result;
  for (int i = start; i <= end; i++) {
    if (!GetInput()[i].empty()) {
      int max_val = *std::max_element(GetInput()[i].begin(), GetInput()[i].end());
      result.push_back(max_val);
    }
  }
  return result;
}
```
